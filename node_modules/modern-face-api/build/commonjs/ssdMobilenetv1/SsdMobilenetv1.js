"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SsdMobilenetv1 = void 0;
const tf = require("@tensorflow/tfjs-core");
const classes_1 = require("../classes");
const FaceDetection_1 = require("../classes/FaceDetection");
const dom_1 = require("../dom");
const NeuralNetwork_1 = require("../NeuralNetwork");
const extractParams_1 = require("./extractParams");
const extractParamsFromWeigthMap_1 = require("./extractParamsFromWeigthMap");
const mobileNetV1_1 = require("./mobileNetV1");
const nonMaxSuppression_1 = require("./nonMaxSuppression");
const outputLayer_1 = require("./outputLayer");
const predictionLayer_1 = require("./predictionLayer");
const SsdMobilenetv1Options_1 = require("./SsdMobilenetv1Options");
class SsdMobilenetv1 extends NeuralNetwork_1.NeuralNetwork {
    constructor() {
        super('SsdMobilenetv1');
    }
    forwardInput(input) {
        const { params } = this;
        if (!params) {
            throw new Error('SsdMobilenetv1 - load model before inference');
        }
        return tf.tidy(() => {
            const batchTensor = tf.cast(input.toBatchTensor(512, false), 'float32');
            const x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1));
            const features = (0, mobileNetV1_1.mobileNetV1)(x, params.mobilenetv1);
            const { boxPredictions, classPredictions } = (0, predictionLayer_1.predictionLayer)(features.out, features.conv11, params.prediction_layer);
            return (0, outputLayer_1.outputLayer)(boxPredictions, classPredictions, params.output_layer);
        });
    }
    async forward(input) {
        return this.forwardInput(await (0, dom_1.toNetInput)(input));
    }
    async locateFaces(input, options = {}) {
        const { maxResults, minConfidence } = new SsdMobilenetv1Options_1.SsdMobilenetv1Options(options);
        const netInput = await (0, dom_1.toNetInput)(input);
        const { boxes: _boxes, scores: _scores } = this.forwardInput(netInput);
        // TODO batches
        const boxes = _boxes[0];
        const scores = _scores[0];
        for (let i = 1; i < _boxes.length; i++) {
            _boxes[i].dispose();
            _scores[i].dispose();
        }
        // TODO find a better way to filter by minConfidence
        const scoresData = Array.from(await scores.data());
        const iouThreshold = 0.5;
        const indices = (0, nonMaxSuppression_1.nonMaxSuppression)(boxes, scoresData, maxResults, iouThreshold, minConfidence);
        const reshapedDims = netInput.getReshapedInputDimensions(0);
        const inputSize = netInput.inputSize;
        const padX = inputSize / reshapedDims.width;
        const padY = inputSize / reshapedDims.height;
        const boxesData = boxes.arraySync();
        const results = indices.map(idx => {
            const [top, bottom] = [Math.max(0, boxesData[idx][0]), Math.min(1.0, boxesData[idx][2])].map(val => val * padY);
            const [left, right] = [Math.max(0, boxesData[idx][1]), Math.min(1.0, boxesData[idx][3])].map(val => val * padX);
            return new FaceDetection_1.FaceDetection(scoresData[idx], new classes_1.Rect(left, top, right - left, bottom - top), {
                height: netInput.getInputHeight(0),
                width: netInput.getInputWidth(0),
            });
        });
        boxes.dispose();
        scores.dispose();
        return results;
    }
    getDefaultModelName() {
        return 'ssd_mobilenetv1_model';
    }
    extractParamsFromWeigthMap(weightMap) {
        return (0, extractParamsFromWeigthMap_1.extractParamsFromWeigthMap)(weightMap);
    }
    extractParams(weights) {
        return (0, extractParams_1.extractParams)(weights);
    }
}
exports.SsdMobilenetv1 = SsdMobilenetv1;
