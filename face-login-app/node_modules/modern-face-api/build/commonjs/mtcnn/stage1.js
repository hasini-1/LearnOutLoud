"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stage1 = stage1;
const tf = require("@tensorflow/tfjs-core");
const classes_1 = require("../classes");
const ops_1 = require("../ops");
const config_1 = require("./config");
const getSizesForScale_1 = require("./getSizesForScale");
const MtcnnBox_1 = require("./MtcnnBox");
const normalize_1 = require("./normalize");
const PNet_1 = require("./PNet");
function rescaleAndNormalize(x, scale) {
    return tf.tidy(() => {
        const { height, width } = (0, getSizesForScale_1.getSizesForScale)(scale, x.shape.slice(1));
        const resized = tf.image.resizeBilinear(x, [height, width]);
        const normalized = (0, normalize_1.normalize)(resized);
        return tf.transpose(normalized, [0, 2, 1, 3]);
    });
}
function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {
    // TODO: fix this!, maybe better to use tf.gather here
    const indices = [];
    const scoresData = scoresTensor.arraySync();
    for (let y = 0; y < scoresTensor.shape[0]; y++) {
        for (let x = 0; x < scoresTensor.shape[1]; x++) {
            if (scoresData[y][x] >= scoreThreshold) {
                indices.push(new classes_1.Point(x, y));
            }
        }
    }
    const boundingBoxes = indices.map(idx => {
        const cell = new classes_1.BoundingBox(Math.round((idx.y * config_1.CELL_STRIDE + 1) / scale), Math.round((idx.x * config_1.CELL_STRIDE + 1) / scale), Math.round((idx.y * config_1.CELL_STRIDE + config_1.CELL_SIZE) / scale), Math.round((idx.x * config_1.CELL_STRIDE + config_1.CELL_SIZE) / scale));
        const score = scoresData[idx.y][idx.x];
        const regionsData = regionsTensor.arraySync();
        const region = new MtcnnBox_1.MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
        return {
            cell,
            score,
            region,
        };
    });
    return boundingBoxes;
}
function stage1(imgTensor, scales, scoreThreshold, params, stats) {
    stats.stage1 = [];
    const pnetOutputs = scales.map(scale => tf.tidy(() => {
        const statsForScale = { scale };
        const resized = rescaleAndNormalize(imgTensor, scale);
        const ts = Date.now();
        const { prob, regions } = (0, PNet_1.PNet)(resized, params);
        statsForScale.pnet = Date.now() - ts;
        const scoresTensor = tf.unstack(tf.unstack(prob, 3)[1])[0];
        const regionsTensor = tf.unstack(regions)[0];
        return {
            scoresTensor,
            regionsTensor,
            scale,
            statsForScale,
        };
    }));
    const boxesForScale = pnetOutputs.map(({ scoresTensor, regionsTensor, scale, statsForScale }) => {
        const boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);
        scoresTensor.dispose();
        regionsTensor.dispose();
        if (!boundingBoxes.length) {
            stats.stage1.push(statsForScale);
            return [];
        }
        const ts = Date.now();
        const indices = (0, ops_1.nonMaxSuppression)(boundingBoxes.map(bbox => bbox.cell), boundingBoxes.map(bbox => bbox.score), 0.5);
        statsForScale.nms = Date.now() - ts;
        statsForScale.numBoxes = indices.length;
        stats.stage1.push(statsForScale);
        return indices.map(boxIdx => boundingBoxes[boxIdx]);
    });
    const allBoxes = boxesForScale.reduce((all, boxes) => all.concat(boxes), []);
    let finalBoxes = [];
    let finalScores = [];
    if (allBoxes.length > 0) {
        const ts = Date.now();
        const indices = (0, ops_1.nonMaxSuppression)(allBoxes.map(bbox => bbox.cell), allBoxes.map(bbox => bbox.score), 0.7);
        stats.stage1_nms = Date.now() - ts;
        finalScores = indices.map(idx => allBoxes[idx].score);
        finalBoxes = indices
            .map(idx => allBoxes[idx])
            .map(({ cell, region }) => new classes_1.BoundingBox(cell.left + region.left * cell.width, cell.top + region.top * cell.height, cell.right + region.right * cell.width, cell.bottom + region.bottom * cell.height)
            .toSquare()
            .round());
    }
    return {
        boxes: finalBoxes,
        scores: finalScores,
    };
}
