"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractImagePatches = extractImagePatches;
const tf = require("@tensorflow/tfjs-core");
const dom_1 = require("../dom");
const env_1 = require("../env");
const normalize_1 = require("./normalize");
async function extractImagePatches(img, boxes, { width, height }) {
    const imgCtx = (0, dom_1.getContext2dOrThrow)(img);
    const bitmaps = await Promise.all(boxes.map(async (box) => {
        // TODO: correct padding
        const { y, ey, x, ex } = box.padAtBorders(img.height, img.width);
        const fromX = x - 1;
        const fromY = y - 1;
        const imgData = imgCtx.getImageData(fromX, fromY, ex - fromX, ey - fromY);
        return env_1.env.isNodejs() ? (0, dom_1.createCanvasFromMedia)(imgData) : createImageBitmap(imgData);
    }));
    const imagePatchesDatas = [];
    bitmaps.forEach(bmp => {
        const patch = (0, dom_1.createCanvas)({ width, height });
        const patchCtx = (0, dom_1.getContext2dOrThrow)(patch);
        patchCtx.drawImage(bmp, 0, 0, width, height);
        const { data } = patchCtx.getImageData(0, 0, width, height);
        const currData = [];
        // RGBA -> BGR
        for (let i = 0; i < data.length; i += 4) {
            currData.push(data[i + 2]);
            currData.push(data[i + 1]);
            currData.push(data[i]);
        }
        imagePatchesDatas.push(currData);
    });
    return imagePatchesDatas.map(data => {
        const t = tf.tidy(() => {
            const imagePatchTensor = tf.cast(tf.transpose(tf.tensor4d(data, [1, width, height, 3]), [0, 2, 1, 3]), 'float32');
            return (0, normalize_1.normalize)(imagePatchTensor);
        });
        return t;
    });
}
